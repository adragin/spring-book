### Комментарий

Аннотация `@Entity` и `@Table` в JPA используются для указания, что класс Java является сущностью, связанной с таблицей в базе данных.

## **Аннотация `@Entity`**

- **Обозначение сущности**: Аннотация `@Entity` указывает, что данный класс является сущностью JPA. Это означает, что экземпляры этого класса могут быть сохранены в базе данных и извлечены из нее.
- **Обязательное требование**: Каждый класс, который должен быть связан с таблицей в базе данных, должен быть аннотирован `@Entity`. Без этой аннотации JPA не будет рассматривать класс как сущность.

## **Аннотация `@Table`**

- **Настройка имени таблицы**: Аннотация `@Table` используется для указания имени таблицы в базе данных, с которой связана сущность. Если эта аннотация не указана, JPA по умолчанию использует имя класса для определения имени таблицы.
- **Дополнительные параметры**: Аннотация `@Table` также позволяет задавать другие параметры, такие как уникальные ограничения и индексы, которые могут быть применены к таблице.

### Обновление

Допустим, нам потребовался метод, который позволит выполнять поиска по полю `engineerName`. Как это реализовать в сущности `Car` с использованием JPA? Для этого нужно расширить интерфейс `CarRepository`, добавив метод поиска. Spring Data JPA позволяет создавать пользовательские методы поиска, просто добавляя их в интерфейс репозитория с использованием соглашений об именах. Вот как это можно сделать:

1. **Расширьте интерфейс `CarRepository`**, добавив метод поиска:

```java
public interface CarRepository extends JpaRepository<Car, Long> {
    List<Car> findByEngineerName(String engineerName);
}
```

2. **Используйте метод в контроллере**:

Теперь вы можете использовать этот метод в вашем контроллере `CarController` для поиска автомобилей по имени инженера:

```java
package ru.ksergey.ContactsApp.controllers;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ru.ksergey.ContactsApp.model.Car;
import ru.ksergey.ContactsApp.repository.CarRepository;

import java.util.List;

@RestController
@RequestMapping("/cars")
public class CarController {

    @Autowired
    private CarRepository carRepository;

    // Другие методы...

    @GetMapping("/search")
    public ResponseEntity<List<Car>> getCarsByEngineerName(@RequestParam String engineerName) {
        List<Car> cars = carRepository.findByEngineerName(engineerName);
        if (cars.isEmpty()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
        return ResponseEntity.status(HttpStatus.OK).body(cars);
    }
}
```

### Объяснение:

- **Метод `findByEngineerName`**: Этот метод автоматически реализуется Spring Data JPA на основе соглашения об именах. Он выполняет поиск всех записей `Car`, где поле `engineerName` совпадает с переданным значением.

- **Контроллер**: В контроллере добавлен новый метод `getCarsByEngineerName`, который принимает параметр `engineerName` и возвращает список автомобилей, соответствующих этому имени. Если список пуст, возвращается статус `NOT_FOUND`.

---

Spring Data JPA позволяет автоматически создавать запросы на основе соглашений об именах методов в репозиториях. Это упрощает написание кода, так как разработчикам не нужно вручную писать SQL или JPQL-запросы. Вместо этого, они могут просто определить метод в интерфейсе репозитория, и Spring Data JPA автоматически сгенерирует соответствующий запрос.

### Как это работает:

1. **Соглашения об именах**: Spring Data JPA использует соглашения об именах для определения логики запроса. Например, если у вас есть сущность `Car` с полем `engineerName`, вы можете создать метод `findByEngineerName` в вашем репозитории. Spring Data JPA автоматически сгенерирует SQL-запрос, который будет искать записи, где `engineerName` соответствует переданному параметру.

2. **Ключевые слова**: В именах методов можно использовать ключевые слова, такие как `And`, `Or`, `Between`, `LessThan`, `GreaterThan`, `Like`, `OrderBy` и другие, чтобы строить более сложные запросы. Например, `findByBrandAndModel` создаст запрос, который ищет автомобили по бренду и модели.

3. **Примеры**:
   - `List<Car> findByEngineerName(String engineerName);` — ищет все автомобили с указанным именем инженера.
   - `List<Car> findByBrandAndModel(String brand, String model);` — ищет автомобили по бренду и модели.
   - `List<Car> findByYearGreaterThan(int year);` — ищет автомобили, выпущенные после указанного года.

### Основные ключевые слова и их использование

1. **And**: Используется для объединения нескольких условий, которые должны быть выполнены одновременно.
   - **Пример**: `findByBrandAndModel(String brand, String model)` — этот метод найдет все автомобили, у которых одновременно совпадают и бренд, и модель.

2. **Or**: Используется для объединения условий, из которых должно быть выполнено хотя бы одно.
   - **Пример**: `findByBrandOrModel(String brand, String model)` — этот метод найдет автомобили, у которых совпадает либо бренд, либо модель.

3. **Between**: Используется для поиска значений в заданном диапазоне.
   - **Пример**: `findByYearBetween(int startYear, int endYear)` — этот метод найдет автомобили, выпущенные в диапазоне от `startYear` до `endYear`.

4. **LessThan / LessThanEqual**: Используется для поиска значений, меньших (или меньших либо равных) указанного.
   - **Пример**: `findByYearLessThan(int year)` — этот метод найдет автомобили, выпущенные до указанного года.

5. **GreaterThan / GreaterThanEqual**: Используется для поиска значений, больших (или больших либо равных) указанного.
   - **Пример**: `findByYearGreaterThan(int year)` — этот метод найдет автомобили, выпущенные после указанного года.

6. **Like**: Используется для поиска значений, соответствующих шаблону. Это аналог SQL-оператора `LIKE`.
   - **Пример**: `findByBrandLike(String pattern)` — этот метод найдет автомобили, бренд которых соответствует заданному шаблону (например, `%Toyota%` для поиска всех брендов, содержащих "Toyota").

7. **OrderBy**: Используется для сортировки результатов.
   - **Пример**: `findByBrandOrderByYearAsc(String brand)` — этот метод найдет все автомобили указанного бренда и отсортирует их по году выпуска в порядке возрастания.

### Ограничения

Хотя ключевые слова обеспечивают мощные возможности для построения запросов, они не всегда подходят для очень сложных или специфичных запросов. В таких случаях можно использовать аннотацию `@Query` для написания собственных JPQL или SQL-запросов.

Таким образом, ключевые слова в Spring Data JPA предоставляют разработчикам удобный и эффективный способ создания запросов, улучшая читаемость и поддерживаемость кода.

[Шаг 14](./step-14.md)
